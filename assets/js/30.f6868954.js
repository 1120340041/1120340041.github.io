(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{196:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h3",{attrs:{id:"_1-new-vue-发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-new-vue-发生了什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. new Vue 发生了什么?")]),e._v(" "),a("p",[e._v("Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等")]),e._v(" "),a("h3",{attrs:{id:"_2-vue模版编译成了什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue模版编译成了什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. vue模版编译成了什么？")]),e._v(" "),a("p",[e._v("编译成render函数，render函数的参数是createElement，最后其实还是调用的createElement")]),e._v(" "),a("h3",{attrs:{id:"_3-createelement是用来干嘛的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-createelement是用来干嘛的？","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. createElement是用来干嘛的？")]),e._v(" "),a("p",[e._v("创建VNode的")]),e._v(" "),a("h3",{attrs:{id:"_4-数组vm-items-indexofitem-newvalue这样修改的话vue能监听到数组变动了吗？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-数组vm-items-indexofitem-newvalue这样修改的话vue能监听到数组变动了吗？","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 数组vm.items[indexOfItem] = newValue这样修改的话vue能监听到数组变动了吗？")]),e._v(" "),a("p",[e._v("watch api不能")]),e._v(" "),a("p",[e._v("不能，vue并没有监听数组索引或者length的变化，出于性能问题的考虑")]),e._v(" "),a("h3",{attrs:{id:"_5-给对象添加新属性是响应式的吗？如果想是响应式的怎么办？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-给对象添加新属性是响应式的吗？如果想是响应式的怎么办？","aria-hidden":"true"}},[e._v("#")]),e._v(" 5. 给对象添加新属性是响应式的吗？如果想是响应式的怎么办？")]),e._v(" "),a("p",[e._v("使用Vue.set")]),e._v(" "),a("h3",{attrs:{id:"_6-什么是vnode？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-什么是vnode？","aria-hidden":"true"}},[e._v("#")]),e._v(" 6. 什么是VNode？")]),e._v(" "),a("p",[e._v("其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。vue的createElement就是用来创建Vnode的。")]),e._v(" "),a("h3",{attrs:{id:"_7-virtual-dom变成真实dom有哪些过程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-virtual-dom变成真实dom有哪些过程？","aria-hidden":"true"}},[e._v("#")]),e._v(" 7. Virtual DOM变成真实DOM有哪些过程？")]),e._v(" "),a("p",[e._v("Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。")]),e._v(" "),a("h3",{attrs:{id:"_8-为什么子组件会比父组件先挂载，先调用mounted方法？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-为什么子组件会比父组件先挂载，先调用mounted方法？","aria-hidden":"true"}},[e._v("#")]),e._v(" 8. 为什么子组件会比父组件先挂载，先调用mounted方法？")]),e._v(" "),a("p",[e._v("猜测因为是递归调用，深度优先，所以是先子组件，子组件属于父组件一部分")]),e._v(" "),a("h3",{attrs:{id:"_9-请问可以在beforecreate钩子内通过this访问到data中定义的变量么，为什么以及请问这个钩子可以做什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-请问可以在beforecreate钩子内通过this访问到data中定义的变量么，为什么以及请问这个钩子可以做什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 9. 请问可以在beforeCreate钩子内通过this访问到data中定义的变量么，为什么以及请问这个钩子可以做什么？")]),e._v(" "),a("p",[e._v("是不可以访问的，因为在vue初始化阶段，这个时候data中的变量还没有被挂载到this上，这个时候访问值会是undefined。beforeCreate这个钩子在平时业务开发中用的比较少，而像插件内部的instanll方法通过Vue.use方法安装时一般会选在beforeCreate这个钩子内执行，vue-router和vuex就是这么干的。")]),e._v(" "),a("h3",{attrs:{id:"_10-props初始化都做了什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-props初始化都做了什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 10.props初始化都做了什么？")]),e._v(" "),a("p",[e._v("props 的初始化主要过程，就是遍历定义的 props 配置。遍历的过程主要做两件事情：一个是调用 defineReactive 方法把每个 prop 对应的值变成响应式，可以通过 vm._props.xxx 访问到定义 props 中对应的属性。对于 defineReactive 方法，我们稍后会介绍；另一个是通过 proxy(Object.defineProperty的语法糖) 把 vm._props.xxx 的访问代理到 vm.xxx 上")]),e._v(" "),a("h3",{attrs:{id:"_11-依赖收集？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-依赖收集？","aria-hidden":"true"}},[e._v("#")]),e._v(" 11.依赖收集？")]),e._v(" "),a("ul",[a("li",[e._v("一个是 const dep = new Dep() 实例化一个 Dep 的实例，另一个是在 get 函数中通过 dep.depend 做依赖收集；")]),e._v(" "),a("li",[e._v("其实很多人都分析过并了解到 Vue 有依赖收集的过程，但我几乎没有看到有人分析依赖清空的过程，其实这是大部分同学会忽视的一点，也是 Vue 考虑特别细的一点。\n考虑到一种场景，我们的模板会根据 v-if 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。")])]),e._v(" "),a("h3",{attrs:{id:"_12-nexttick？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-nexttick？","aria-hidden":"true"}},[e._v("#")]),e._v(" 12.nextTick？")]),e._v(" "),a("p",[e._v("在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then。\n通过这一节对 nextTick 的分析，并结合上一节的 setter 分析，我们了解到数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。这就是我们平时在开发的过程中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。")])])}],!1,null,null,null);t.default=s.exports}}]);